// Generated by CoffeeScript 1.6.2
(function() {
  var alignPredicate, amqp, inflect, neo, push2namesParser, store2neo, _, _getNodeType, _getNodes;

  _ = require("underscore");

  inflect = require("underscore.inflections");

  neo = require("../../baio-neo4j/neo4j");

  amqp = require("../../baio-amqp/amqp");

  neo.setConfig({
    uri: process.env.NEO4J_URI
  });

  alignPredicate = function(predicate) {
    var p;

    p = "" + (predicate.toLowerCase().match(/^.*\/(.*)$/)[1]);
    p = inflect.singularize(p);
    return "da:" + p;
  };

  _getNodeType = function(link, isSubject) {
    if (isSubject) {
      switch (link.type) {
        case "person_person":
          return "person";
        case "person_org":
          return "person";
        default:
          return "org";
      }
    } else {
      switch (link.type) {
        case "person_person":
          return "person";
        case "org_person":
          return "person";
        default:
          return "org";
      }
    }
  };

  _getNodes = function(links) {
    var nodesObj, nodesSubj;

    nodesSubj = links.map(function(l) {
      return {
        node: l.subject,
        type: _getNodeType(l, true)
      };
    });
    nodesObj = links.map(function(l) {
      return {
        node: l.object,
        type: _getNodeType(l, false)
      };
    });
    return nodesSubj.concat(nodesObj);
  };

  push2namesParser = function(data) {
    var nodes;

    nodes = _.uniq(_getNodes(data.links), false, function(i) {
      return JSON.stringify(i);
    });
    return amqp.pub(process.env.CRAWLER_NAMES_APP_NAME, {
      predicates: data.predicates,
      nodes: nodes
    });
  };

  store2neo = function(links, done) {
    var batch, i, l, nodes, _i, _len;

    if (links.length === 0) {
      done(null, []);
      return;
    }
    nodes = _getNodes(links);
    i = 0;
    for (i = _i = 0, _len = links.length; _i < _len; i = ++_i) {
      l = links[i];
      l.nodes = [i, i + 1];
      i += 2;
    }
    batch = {
      nodeOpts: {
        index: "wiki",
        keyValue: function(m) {
          return {
            uri: m.node
          };
        },
        properties: function(m) {
          return {
            type: m.type
          };
        }
      },
      nodes: nodes,
      relOpts: {
        type: function(m) {
          return m.predicate;
        },
        nodesIndexes: function(m) {
          return m.nodes;
        }
      },
      rels: links
    };
    return neo.createBatch(batch, done);
  };

  exports.parseBindings = function(batch) {
    return batch.results.bindings.map(function(d) {
      return d.s.value;
    });
  };

  exports.parseLinks = function(batch, data, done) {
    var linked, links, predicates;

    linked = batch.results.bindings.map(function(m) {
      return {
        object: m.o.value,
        predicate: m.p.value
      };
    });
    predicates = linked.map(function(m) {
      return {
        key: m.predicate,
        aligned: alignPredicate(m.predicate)
      };
    });
    links = linked.map(function(m) {
      return {
        subject: data.subject,
        predicate: alignPredicate(m.predicate),
        object: m.object,
        type: data.type
      };
    });
    console.log(links);
    predicates = _.uniq(predicates, false, function(i) {
      return JSON.stringify(i);
    });
    links = _.uniq(links, false, function(i) {
      return JSON.stringify(i);
    });
    push2namesParser({
      predicates: predicates,
      links: links
    });
    return store2neo(links, done);
  };

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
