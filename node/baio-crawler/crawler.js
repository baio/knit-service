// Generated by CoffeeScript 1.6.2
(function() {
  var amqp, async, log, parseLevel, push2Amqp, req, request, requestAndParse, start, _opts, _parse;

  async = require("async");

  req = require("request");

  amqp = require("../baio-amqp/amqp");

  log = require("./logs");

  _opts = null;

  _parse = null;

  push2Amqp = function(level, urls) {
    var url, _i, _len, _results;

    if (urls && urls.length) {
      _results = [];
      for (_i = 0, _len = urls.length; _i < _len; _i++) {
        url = urls[_i];
        log.write(log.LOG_CODE_AMQP_PUSH, {
          level: level,
          url: url
        });
        _results.push(amqp.pub(_opts.amqp.queue, {
          level: level,
          url: url
        }));
      }
      return _results;
    }
  };

  request = function(url, done) {
    var opts;

    if (typeof url === "object") {
      opts = url.request;
    } else {
      opts = {
        url: !url.match(/https?:\/\//) ? "http://" + url : void 0,
        method: "get"
      };
    }
    log.write(log.LOG_CODE_REQ, opts);
    return req(opts, done);
  };

  requestAndParse = function(level, url, done) {
    return async.waterfall([
      function(ck) {
        return request(url, ck);
      }, function(resp, body, ck) {
        var data;

        log.write(log.LOG_CODE_REQ_RESP, body);
        if (typeof url === "object") {
          data = url.data;
        }
        return _parse(level, body, data, ck);
      }
    ], done);
  };

  parseLevel = function(level, url, done) {
    var _done;

    _done = function(err, links) {
      if (!err) {
        push2Amqp(level + 1, links);
      }
      return done(err, links);
    };
    log.write(log.LOG_CODE_PARSE_LEVEL, {
      level: level,
      url: url
    });
    if (url) {
      return requestAndParse(level, url, _done);
    } else {
      return _parse(level, null, null, _done);
    }
  };

  start = function(opts, parse, done) {
    _opts = opts;
    _parse = parse;
    amqp.setConfig(opts.amqp.config);
    log.setOpts(opts.log);
    return amqp.connect(function() {
      return amqp.sub({
        queue: opts.amqp.queue,
        onPop: function(data, ack) {
          log.write(log.LOG_CODE_AMQP_ON_POP, data);
          return parseLevel(data.level, data.url, function(err) {
            if (!err) {
              return ack();
            }
          });
        }
      }, function(err) {
        log.write(log.LOG_CODE_AMQP_CONNECT, err);
        done(err);
        if (!err) {
          return parseLevel(-1, null, function() {});
        }
      });
    });
  };

  exports.start = start;

}).call(this);

/*
//@ sourceMappingURL=crawler.map
*/
