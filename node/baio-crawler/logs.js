// Generated by CoffeeScript 1.6.2
(function() {
  var appendWriter, async, consoleWriter, write, _getLvl, _opts, _writers,
    _this = this,
    __hasProp = {}.hasOwnProperty;

  async = require("async");

  exports.LOG_LVL_HIGH = 1000;

  exports.LOG_LVL_MID = 500;

  exports.LOG_LVL_LOW = 0;

  exports.LOG_CODE_AMQP_CONNECT = "LOG_CODE_AMQP_CONNECT";

  exports.LOG_CODE_PARSER_ERROR = "LOG_CODE_PARSER_ERROR";

  exports.LOG_CODE_REQ_ERROR = "LOG_CODE_REQ_ERROR";

  exports.LOG_CODE_AMQP_PUSH = "LOG_CODE_AMQP_PUSH";

  exports.LOG_CODE_AMQP_ON_POP = "LOG_CODE_AMQP_ON_POP";

  exports.LOG_CODE_REQ = "LOG_CODE_REQ";

  exports.LOG_CODE_REQ_RESP = "LOG_CODE_REQ_RESP";

  exports.LOG_CODE_PARSE_LEVEL = "LOG_CODE_PARSE_LEVEL";

  _opts = null;

  _writers = [];

  _getLvl = function(code) {
    switch (code) {
      case exports.LOG_CODE_AMQP_CONNECT:
        return exports.LOG_LVL_HIGH;
      case exports.LOG_CODE_PARSER_ERROR:
        return exports.LOG_LVL_HIGH;
      case exports.LOG_CODE_REQ_ERROR:
        return exports.LOG_LVL_HIGH;
      case exports.LOG_CODE_AMQP_PUSH:
        return exports.LOG_LVL_MID;
      case exports.LOG_CODE_AMQP_ON_POP:
        return exports.LOG_LVL_MID;
      case exports.LOG_CODE_REQ:
        return exports.LOG_LVL_LOW;
      case exports.LOG_CODE_REQ_RESP:
        return exports.LOG_LVL_LOW;
      case exports.LOG_CODE_PARSE_LEVEL:
        return exports.LOG_LVL_LOW;
    }
  };

  consoleWriter = function(lvl, code, msg) {
    return console.log(lvl, code, msg);
  };

  appendWriter = function(writer) {
    return _writers.push(writer);
  };

  write = function(lvl, code, msg) {
    var wr, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = _writers.length; _i < _len; _i++) {
      wr = _writers[_i];
      _results.push(wr(lvl, code, msg));
    }
    return _results;
  };

  exports.setOpts = function(opts, done) {
    var prop, wrs, _ref;

    _opts = opts;
    if (typeof opts.write === "object") {
      wrs = [];
      _ref = opts.write;
      for (prop in _ref) {
        if (!__hasProp.call(_ref, prop)) continue;
        wrs.push(prop);
      }
      return async.map(wrs, function(name, ck) {
        if (name === "loggly") {
          return exports.getLoggly(opts.write["loggly"], function(err, writer) {
            return ck(err, writer);
          });
        } else if (name === "console") {
          return ck(null, (opts.write["console"] ? consoleWriter : null));
        } else {
          return ck(null, opts.write[name]);
        }
      }, function(err, results) {
        var r, _i, _len, _ref1;

        if (!err) {
          _ref1 = results.filter(function(f) {
            return f;
          });
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            r = _ref1[_i];
            appendWriter(r);
          }
        }
        return done(err);
      });
    } else {
      appendWriter(opts.write);
      return done();
    }
  };

  exports.write = function(code, msg) {
    if (_opts) {
      return exports.writeLvl(_getLvl(code), code, msg);
    }
  };

  exports.writeLvl = function(lvl, code, msg) {
    if (_opts && _opts.level <= lvl) {
      return write(lvl, code, msg);
    }
  };

  exports.getLoggly = function(opts, done) {
    var client, config, loggly;

    loggly = require("loggly");
    config = {
      subdomain: opts.domain,
      auth: {
        username: opts.username,
        password: opts.password
      },
      json: true
    };
    client = loggly.createClient(config);
    return client.getInput(opts.input, function(err, input) {
      if (!err) {
        return done(err, function(lvl, code, msg) {
          return input.log({
            level: lvl,
            code: code,
            msg: msg
          });
        });
      } else {
        return done(err);
      }
    });
  };

}).call(this);

/*
//@ sourceMappingURL=logs.map
*/
