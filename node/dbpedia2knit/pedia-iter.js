// Generated by CoffeeScript 1.6.2
(function() {
  var async, createNames, createPrdeicateNames, createRels, es, getChildrenOrgs, getChildrenPeople, getName, getNames, init_people_query, mongo, mongodb, _ES_URI, _SPARQL_URI, _iter, _iterSubjects, _names, _q, _q_children_orgs, _q_children_people, _q_org_name, _q_person_name, _q_predicate_name;

  async = require("async");

  _q = require("./pedia-query");

  _q_person_name = require("./pedia-person-name");

  _q_org_name = require("./pedia-org-name");

  _q_predicate_name = require("./pedia-predicate-name");

  _q_children_people = require("./pedia-children-people");

  _q_children_orgs = require("./pedia-children-orgs");

  es = require("../baio-es/es");

  mongo = require("../baio-mongo/mongo");

  mongodb = require("mongodb");

  _ES_URI = process.env.ES_URI;

  _SPARQL_URI = "http://dbpedia.org/sparql";

  mongo.setConfig({
    uri: process.env.MONGO_URI
  });

  init_people_query = "select distinct ?s\nwhere\n{\n{?s dcterms:subject category:Russian_businesspeople.}\nunion\n{?s dcterms:subject category:Russian_politicians.}\nunion\n{?s a yago:RussianPoliticians.}\n  }";

  getName = function(s, isPerson, done) {
    if (isPerson) {
      return _q_person_name(_SPARQL_URI, s, done);
    } else {
      return _q_org_name(_SPARQL_URI, s, done);
    }
  };

  getNames = function(s, isPerson, done) {
    return async.map(s, (function(i, ck) {
      return getName(i, isPerson, ck);
    }), done);
  };

  getChildrenOrgs = function(s, done) {
    return async.map(s, (function(i, ck) {
      return _q_children_orgs(_SPARQL_URI, i, ck);
    }), done);
  };

  getChildrenPeople = function(s, done) {
    return async.map(s, (function(i, ck) {
      return _q_children_people(_SPARQL_URI, i, ck);
    }), done);
  };

  _names = [];

  createPrdeicateNames = function(domain, items) {
    return async.map(items, (function(i, ck) {
      return _q_predicate_name(_SPARQL_URI, i, ck);
    }), function(err, results) {
      var data, r, _i, _len, _results;

      if (!err) {
        _results = [];
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          r = results[_i];
          data = r.map(function(m) {
            return {
              _id: m.name + ":" + m.lang,
              _type: domain,
              val: m.name,
              lang: m.lang,
              uri: m.id
            };
          });
          _results.push(es.bulk(_ES_URI, "predicates", data, function() {}));
        }
        return _results;
      }
    });
  };

  createNames = function(domain, isPerson, items) {
    var data, i, _i, _len;

    data = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      i = items[_i];
      data = data.concat(i.map(function(m) {
        return {
          _id: m.name + ":" + m.lang,
          _type: domain,
          val: m.name,
          lang: m.lang,
          uri: m.id
        };
      }));
    }
    return es.bulk(_ES_URI, (isPerson ? "person-names" : "org-names"), data, function() {});
  };

  createRels = function(domain, predicateType, rels) {
    var doc, items, name, r, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = rels.length; _i < _len; _i++) {
      r = rels[_i];
      if (r) {
        items = r.map(function(m) {
          return {
            _id: new mongodb.ObjectID(),
            domain: domain,
            type: predicateType,
            subject: m.subject,
            object: m.object,
            predicate: m.predicate,
            url: m.subject
          };
        });
        if (items.length > 0) {
          name = items[0].subject.match(/^.*\/(.*)$/)[1];
          doc = {
            name: "" + domain + " - " + predicateType + " - " + name,
            created: new Date(),
            descr: "This set was created automatically, from dbpedia",
            url: items[0].subject,
            items: items
          };
          createPrdeicateNames(domain, items.map(function(m) {
            return m.predicate;
          }));
          _results.push(mongo.insert("contribs", doc, function(err, item) {}));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _iterSubjects = function(s, isPerson, done) {
    return async.parallel([
      function(ck) {
        return getNames(s, isPerson, ck);
      }, function(ck) {
        return getChildrenOrgs(s, ck);
      }, function(ck) {
        return getChildrenPeople(s, ck);
      }
    ], function(err, results) {
      var names, newOrgs, newPeople, orgsRels, peopleRels, r, rel, res, _i, _j, _k, _l, _len, _len1, _len2, _len3;

      names = results[0];
      orgsRels = results[1];
      peopleRels = results[2];
      newPeople = [];
      newOrgs = [];
      if (names) {
        createNames("wiki", isPerson, names);
      }
      if (peopleRels) {
        if (isPerson) {
          createRels("wiki", "pp", peopleRels);
          createRels("wiki", "po", orgsRels);
        } else {
          createRels("wiki", "op", peopleRels);
          createRels("wiki", "oo", orgsRels);
        }
        res = [];
        for (_i = 0, _len = peopleRels.length; _i < _len; _i++) {
          r = peopleRels[_i];
          for (_j = 0, _len1 = r.length; _j < _len1; _j++) {
            rel = r[_j];
            if (res.indexOf(rel.object) === -1) {
              res.push(rel.object);
            }
          }
        }
        newPeople = res.filter(function(f) {
          return _names.indexOf(f) === -1;
        });
        res = [];
        for (_k = 0, _len2 = orgsRels.length; _k < _len2; _k++) {
          r = orgsRels[_k];
          for (_l = 0, _len3 = r.length; _l < _len3; _l++) {
            rel = r[_l];
            if (res.indexOf(rel.object) === -1) {
              res.push(rel.object);
            }
          }
        }
        newOrgs = res.filter(function(f) {
          return _names.indexOf(f) === -1;
        });
      }
      if (newPeople.length === 0 && newOrgs.length === 0) {
        return done();
      } else {
        _names = _names.concat(newPeople);
        _names = _names.concat(newOrgs);
        return async.parallel([
          function(ck) {
            return _iterSubjects(newPeople, true, ck);
          }, function(ck) {
            console.log(newOrgs);
            return _iterSubjects(newOrgs, false, ck);
          }
        ], done);
      }
    });
  };

  _iter = function(query, isPerson, done) {
    return _q(_SPARQL_URI, query, function(err, data) {
      var s;

      if (!err) {
        s = data.map(function(d) {
          return d.s.value;
        });
        return _iterSubjects(s, isPerson, done);
      } else {
        return done(err);
      }
    });
  };

  module.exports = function(done) {
    return _iter(init_people_query, true, done);
  };

}).call(this);

/*
//@ sourceMappingURL=pedia-iter.map
*/
