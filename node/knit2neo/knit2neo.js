// Generated by CoffeeScript 1.6.2
(function() {
  var async, convert, es, mongo, neo, undesrcore, _ES_URI, _LANGS, _alignPredicate, _getIndex, _getLinkName, _getNodeName, _groupLinks, _isUri, _map, _mapLink, _readAndConvert, _updateLinks;

  async = require("async");

  mongo = require("../baio-mongo/mongo");

  es = require("../baio-es/es");

  neo = require("../baio-neo4j/neo4j");

  undesrcore = require("underscore.inflections");

  _ES_URI = process.env.ES_URI;

  _LANGS = ["ru", "en"];

  neo.setConfig({
    uri: process.env.NEO4J_URI
  });

  _isUri = function(name) {
    if (name.match(/^\w+:.*$/)) {
      return true;
    } else {
      return false;
    }
  };

  _getIndex = function(name, type, val, done) {
    var q;

    if (_isUri(val)) {
      q = {
        query: {
          term: {
            uri: val
          }
        }
      };
    } else {
      q = {
        query: {
          query_string: {
            query: val
          }
        }
      };
    }
    return es.query(_ES_URI, name, q, function(err, data) {
      var res;

      if (!err && data && data.length) {
        res = {
          uri: data[0].uri,
          names: data.map(function(m) {
            return {
              name: m.name,
              lang: m.lang
            };
          })
        };
      } else {
        res = {
          uri: val,
          names: [
            {
              name: val,
              lang: "en"
            }
          ]
        };
      }
      return done(null, res);
    });
  };

  _getLinkName = function(name, dom, done) {
    return _getIndex("predicates", dom, name, function(err, data) {
      if (!err) {
        data.uri = _alignPredicate(data.uri);
      }
      return done(err, data);
    });
  };

  _getNodeName = function(name, dom, type, done) {
    return _getIndex("" + type + "-names", dom, name, done);
  };

  _alignPredicate = function(predicate) {
    var p;

    if (_isUri(predicate)) {
      p = "" + (predicate.toLowerCase().match(/^.*\/(.*)$/)[1]);
      p = undesrcore.singularize(p);
      return "da:" + p;
    } else {
      return predicate;
    }
  };

  _mapLink = function(item, done) {
    return async.parallel([
      function(ck) {
        return _getLinkName(item.predicate, item.dom, ck);
      }, function(ck) {
        return _getNodeName(item.subject, item.dom, (item.type === "po" || item.type === "pp" ? "person" : "org"), ck);
      }, function(ck) {
        return _getNodeName(item.object, item.dom, (item.type === "op" || item.type === "pp" ? "person" : "org"), ck);
      }
    ], function(err, results) {
      var res;

      res = {
        predicate: results[0],
        subject: results[1],
        object: results[2],
        url: item.url,
        contrib: item._id.toString()
      };
      return done(null, res);
    });
  };

  _groupLinks = function(links) {
    var link, r, res, _i, _len;

    res = [];
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      r = res.filter(function(f) {
        return f.predicate.uri === link.predicate.uri && f.subject.uri === link.subject.uri && f.object.uri === link.object.uri;
      })[0];
      if (!r) {
        r = link;
        r.contribs = [];
        r.urls = [];
        res.push(r);
      }
      if (r.urls.indexOf(link.url) === -1) {
        r.urls.push(link.url);
      }
      if (r.contribs.indexOf(link.contrib) === -1) {
        r.contribs.push(link.contrib);
      }
    }
    return res;
  };

  _updateLinks = function(links, done) {
    var i, link, nodes, _i, _len;

    nodes = [];
    i = 0;
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      link.nodes = [i, i + 1];
      nodes.push(link.object);
      nodes.push(link.subject);
      i += 2;
    }
    return neo.createBatch({
      nodeOpts: {
        index: "wiki",
        keyValue: function(m) {
          return {
            uri: m.uri
          };
        },
        properties: function(m) {
          return {
            names: m.names.map(function(m) {
              return m.lang + ":" + m.name;
            })
          };
        }
      },
      nodes: nodes,
      relOpts: {
        type: function(m) {
          return m.predicate.uri;
        },
        nodesIndexes: function(m) {
          return m.nodes;
        },
        properties: function(m, n) {
          var r, u, _j, _k, _len1, _len2, _ref, _ref1, _ref2, _ref3;

          r = {
            names: m.names.map(function(m) {
              return m.lang + ":" + m.name;
            }),
            urls: m.urls,
            contribs: m.contribs
          };
          _ref1 = (_ref = n.data) != null ? _ref.urls : void 0;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            u = _ref1[_j];
            if (r.urls.indexOf(u) === -1) {
              r.urls.push(u);
            }
          }
          _ref3 = (_ref2 = n.data) != null ? _ref2.contribs : void 0;
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            u = _ref3[_k];
            if (r.contribs.indexOf(u) === -1) {
              r.contribs.push(u);
            }
          }
          return r;
        }
      },
      rels: links
    }, done);
  };

  _map = function(items, done) {
    return async.map(items, (function(i, ck) {
      return _mapLink(i, ck);
    }), function(err, links) {
      links = _groupLinks(links);
      return _updateLinks(links, done);
    });
  };

  _readAndConvert = function(coll, done) {
    var cursor, f;

    f = true;
    cursor = coll.find();
    return async.whilst(function() {
      return f;
    }, function(ck) {
      return cursor.nextObject(function(err, doc) {
        if (!err) {
          if (doc) {
            return _map(doc.items, ck);
          } else {
            f = false;
            return ck();
          }
        } else {
          return ck();
        }
      });
    }, done);
  };

  convert = function(done) {
    mongo.setConfig({
      uri: process.env.MONGO_URI
    });
    return async.waterfall([
      function(ck) {
        return mongo.open("contribs", ck);
      }, function(coll, ck) {
        return _readAndConvert(coll, function(err) {
          return ck(err, coll);
        });
      }
    ], function(err, coll) {
      if (coll) {
        mongo.close(coll);
      }
      return done(err);
    });
  };

  convert(function(err) {
    return console.log(err);
  });

}).call(this);

/*
//@ sourceMappingURL=knit2neo.map
*/
