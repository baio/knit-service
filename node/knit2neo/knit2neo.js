// Generated by CoffeeScript 1.6.2
(function() {
  var async, convert, es, mongo, neo, _ES_URI, _LANGS, _alignPredicate, _getIndex, _getLinkName, _getNodeName, _groupLinks, _isUri, _map, _mapLink, _readAndConvert, _updateLinks;

  async = require("async");

  mongo = require("../baio-mongo/mongo");

  es = require("../baio-es/es");

  neo = require("../baio-neo4j/neo4j");

  _ES_URI = process.env.ES_URI;

  _LANGS = ["ru", "en"];

  neo.setConfig({
    uri: process.env.NEO4J_URI
  });

  _isUri = function(name) {
    if (name.match(/^\w+:.*$/)) {
      return true;
    } else {
      return false;
    }
  };

  _getIndex = function(name, type, val, done) {
    var q;

    if (_isUri(val)) {
      q = {
        query: {
          term: {
            uri: val
          }
        }
      };
    } else {
      q = {
        query: {
          query_string: {
            query: val
          }
        }
      };
    }
    return es.query(_ES_URI, name, q, function(err, data) {
      var res;

      if (!err && data && data.length) {
        res = {
          uri: data[0].uri,
          names: data.map(function(m) {
            return {
              name: m.name,
              lang: m.lang
            };
          })
        };
      } else {
        res = {
          uri: val,
          names: [
            {
              name: val,
              lang: "en"
            }
          ]
        };
      }
      return done(null, res);
    });
  };

  _getLinkName = function(name, dom, done) {
    return _getIndex("predicates", dom, name, function(err, data) {
      if (!err) {
        data.uri = _alignPredicate(data.uri);
      }
      return done(err, data);
    });
  };

  _getNodeName = function(name, dom, type, done) {
    return _getIndex("" + type + "-names", dom, name, done);
  };

  _alignPredicate = function(predicate) {
    if (_isUri(predicate)) {
      return "da:" + (predicate.toLowerCase().match(/^.*\/(.*)$/)[1]);
    } else {
      return predicate;
    }
  };

  _mapLink = function(item, done) {
    return async.parallel([
      function(ck) {
        return _getLinkName(item.predicate, item.dom, ck);
      }, function(ck) {
        return _getNodeName(item.subject, item.dom, (item.type === "po" || item.type === "pp" ? "person" : "org"), ck);
      }, function(ck) {
        return _getNodeName(item.object, item.dom, (item.type === "op" || item.type === "pp" ? "person" : "org"), ck);
      }
    ], function(err, results) {
      var res;

      res = {
        predicate: results[0],
        subject: results[1],
        object: results[2],
        url: item.url,
        contrib: item._id.toString()
      };
      return done(null, res);
    });
  };

  _groupLinks = function(links) {
    var link, r, res, _i, _len;

    res = [];
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      r = res.filter(function(f) {
        return f.predicate.uri === link.predicate.uri && f.subject.uri === link.subject.uri && f.object.uri === link.object.uri;
      })[0];
      if (!r) {
        r = link;
        r.contribs = [];
        r.urls = [];
        res.push(r);
      }
      if (r.urls.indexOf(link.url) === -1) {
        r.urls.push(link.url);
      }
      if (r.contribs.indexOf(link.contrib) === -1) {
        r.contribs.push(link.contrib);
      }
    }
    return res;
  };

  _updateLinks = function(links) {
    "{ predicate: { uri: 'da:almamater', names: [Object] },\nsubject:\n{ uri: 'http://dbpedia.org/resource/Alexei_Kudrin',\nnames: [Object] },\nobject:\n{ uri: 'http://dbpedia.org/resource/Saint_Petersburg_State_University',\nnames: [Object] },\nurl: 'http://dbpedia.org/resource/Alexei_Kudrin',\ncontrib: '51d12046de605ab817000247',\ncontribs: [ '51d12046de605ab817000247' ],\nurls: [ 'http://dbpedia.org/resource/Alexei_Kudrin' ] }";
    var link, nodes, rel, relations, _i, _len;

    nodes = [];
    relations = [];
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      nodes.push(link.subject);
      nodes.push(link.object);
      rel = link.predicate;
      rel.urls = link.urls;
      rel.contribs = link.contribs;
      relations.push(rel);
    }
    console.log(nodes);
    return console.log(relations);
  };

  _map = function(items) {
    return async.map(items, (function(i, ck) {
      return _mapLink(i, ck);
    }), function(err, links) {
      links = _groupLinks(links);
      return _updateLinks(links);
    });
  };

  _readAndConvert = function(coll, done) {
    return coll.find().each(function(err, doc) {
      if (!err) {
        if (doc) {
          return _map(doc.items);
        } else {
          return done();
        }
      }
    });
  };

  convert = function(done) {
    mongo.setConfig({
      uri: process.env.MONGO_URI
    });
    return async.waterfall([
      function(ck) {
        return mongo.open("contribs", ck);
      }, function(coll, ck) {
        return _readAndConvert(coll, function(err) {
          return ck(err, coll);
        });
      }
    ], function(err, coll) {
      if (coll) {
        mongo.close(coll);
      }
      return done(err);
    });
  };

  convert(function(err) {
    return console.log(err);
  });

}).call(this);

/*
//@ sourceMappingURL=knit2neo.map
*/
